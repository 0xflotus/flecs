
#ifndef FLECS_H
#define FLECS_H

#include <stdint.h>
#include <alloca.h>
#include <time.h>
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>

/* Utility file generated by bake */
#include "bake_config.h"

/* The following symbols are used in the time complexity annotations:
 * e: number of entities
 * c: number of components for a specified entity
 * s: number of systems
 * C: average number of components per entity in a world
 * t: number of entities in a matching tables
 * r: combined size of all components for one entity (a 'row')
 */

/* -- The API uses the native bool type in C++, or a custom one in C -- */

#ifndef __cplusplus
#undef bool
#undef true
#undef false
#define bool char
#define false 0
#define true !false
#endif

#define ECS_HANDLE_NIL (0)

/** Function return values */
typedef enum EcsResult {
    EcsOk,
    EcsError
} EcsResult;

/* The flecs world object */
typedef struct EcsWorld EcsWorld;

/** A handle identifies an entity */
typedef uint64_t EcsEntity;

/* Utility headers */
#include "util/iter.h"
#include "util/array.h"
#include "util/map.h"
#include "util/stats.h"
#include "util/time.h"

/** -- Builtin module flags -- */
#define ECS_2D (1)
#define ECS_3D (2)

#ifdef __cplusplus
extern "C" {
#endif


/* -- Supporting types -- */

/** A hash of the component identifiers in a type. */
typedef uint32_t EcsType;

/** Id component type */
typedef const char *EcsId;

/** System kinds determine when and how systems are ran */
typedef enum EcsSystemKind {
    /* Periodic systems */
    EcsOnLoad,
    EcsPreFrame,
    EcsOnFrame,
    EcsPostFrame,
    EcsOnStore,

    /* On demand systems */
    EcsManual,

    /* Reactive systems */
    EcsOnAdd,
    EcsOnRemove,
    EcsOnSet,
} EcsSystemKind;

/** Reference to a component from another entity */
typedef struct EcsReference {
    EcsEntity entity;
    EcsType component;
} EcsReference;

/** Data passed to system action callback, used for iterating entities */
typedef struct EcsRows {
    EcsWorld *world;     /* current world */
    EcsEntity system;    /* handle to current system */

    int32_t *columns;    /* indices mapping system params to columns and refs */
    uint16_t column_count; /* Number of columns for system */
    void *table_columns; /* opaque structure that contains table column data */
    EcsReference *references; /* references to other entities */
    EcsEntity *components;    /* system-table specific list of components */

    void *param;         /* userdata passed to on-demand system */
    float delta_time;    /* time elapsed since last frame */
    uint32_t index_offset; /* number of rows processed by system in this frame */
    uint32_t count;      /* System should process count rows */
    uint32_t begin;     /* System should start iteration from begin */
    uint32_t end;        /* Convenience variable that holds begin + count */
    EcsEntity interrupted_by; /* when set, system execution is interrupted */
} EcsRows;

/** System action callback type */
typedef void (*EcsSystemAction)(
    EcsRows *data);

/** Initialization function signature of modules */
typedef void (*EcsModuleInitAction)(
    EcsWorld *world,
    int flags,
    void *handles_out);

/** Handles to builtin components */
#define EEcsComponent (1)
#define EEcsTypeComponent (2)
#define EEcsPrefab (3)
#define EEcsRowSystem (4)
#define EEcsColSystem (5)
#define EEcsId (6)
#define EEcsHidden (7)
#define EEcsContainer (8)

FLECS_EXPORT
extern EcsType 
    TEcsComponent,
    TEcsTypeComponent,
    TEcsPrefab,
    TEcsRowSystem,
    TEcsColSystem,
    TEcsId,
    TEcsHidden,
    TEcsContainer;

/* This allows passing 0 as type to functions that accept types */
#define T0 (0)

FLECS_EXPORT
extern const char 
    *ECS_COMPONENT_ID,
    *ECS_TYPE_COMPONENT_ID,
    *ECS_PREFAB_ID,
    *ECS_ROW_SYSTEM_ID,
    *ECS_COL_SYSTEM_ID,
    *ECS_ID_ID,
    *ECS_HIDDEN_ID,
    *ECS_CONTAINER_ID;

/* -- World API -- */

/** Create a new world.
 * A world manages all the ECS objects. Applications must have at least one
 * world. Entities, component and system handles are local to a world and
 * cannot be shared between worlds.
 *
 * @time-complexity: O(1)
 * @returns A new world object
 */
FLECS_EXPORT
EcsWorld* ecs_init(void);

/** Delete a world.
 * This operation deletes the world, and all entities, components and systems
 * within the world.
 *
 * @time-complexity: O(n)
 * @param world The world to delete.
 */
FLECS_EXPORT
EcsResult ecs_fini(
    EcsWorld *world);

/** Signal exit
 * This operation signals that the application should quit. It will cause
 * ecs_progress to return false.
 *
 * @time-complexity: O(1)
 * @param world The world to quit.
 */
FLECS_EXPORT
void ecs_quit(
    EcsWorld *world);

/** Import a flecs module.
 * Flecs modules enable reusing components and systems across projects. To
 * use a module, a project needs to link with its library and include its header
 * file.
 *
 * The module returns a struct with handles to the loaded components / systems
 * so they can be accessed by the application. Note that if the module is loaded
 * in different worlds, the handles may not be the same.
 *
 * These naming conventions are not enforced, and projects are free to use their
 * own conventions, though these are the conventions used by the modules
 * provided by flecs.
 *
 * The load function has an additional flags argument which is passed to the
 * module, and is intended to allow applications to select only features they
 * require from a module. The mapping granularity of flags to components/systems
 * is to be defined by the module.
 *
 * This function is wrapped by the ECS_IMPORT convenience macro:
 *
 * ECS_IMPORT(world, EcsComponentsTransform 0);
 *
 * This macro automatically creates a variable called eEcsComponentsTransform
 * that is the struct with the handles for that component.
 *
 * @param world The world.
 * @param module The module to load.
 * @param flags A bitmask that specifies which parts of the module to load.
 * @param handles_out A struct with handles to the module components/systems.
 */
FLECS_EXPORT
EcsEntity ecs_import(
    EcsWorld *world,
    EcsModuleInitAction module,
    const char *module_name,
    int flags,
    void *handles_out,
    size_t handles_size);

/** Progress a world.
 * This operation progresses the world by running all systems that are both
 * enabled and periodic on their matching entities.
 *
 * To ensure consistency of the data, mutations that add/remove components or
 * create/delete entities are staged and merged after all systems are evaluated.
 * When using multiple threads, each thread will have its own "staging area".
 * Threads will be able to see their own changes, but may not see changes from
 * other threads until changes are merged.
 *
 * Staging only occurs when ecs_progress is executing systems. The operations
 * that use staging are:
 *
 * - ecs_new
 * - ecs_new_w_count
 * - ecs_clone
 * - ecs_delete
 * - ecs_add
 * - ecs_remove
 * - ecs_set
 *
 * By default, staged data is merged each time ecs_progress has evaluated all
 * systems. An application may choose to manually merge instead, by setting
 * auto-merging to false with ecs_set_automerge and invoking ecs_merge when a
 * merge is required. In applications with relatively lots of data to merge,
 * this can significantly boost performance.
 *
 * It should be noted that delaying a merge in a multithreaded application
 * causes temporary inconsistencies between threads. A thread will be able to
 * see changes from the previous iteration, but will not be able to see updates
 * from other threads until a merge has taken place.
 *
 * Note that staging only occurs for changes caused by the aforementioned
 * functions. If a system makes in-place modifications to components (through
 * pointers obtained with ecs_data) they will be "instantly" visible to other
 * threads.
 *
 * An application can pass a delta_time into the function, which is the time
 * passed since the last frame. This value is passed to systems so they can
 * update entity values proportional to the elapsed time since their last
 * invocation.
 *
 * By passing the delta_time into ecs_progress, an application can take full
 * control of the "speed" at which entities are progressed. This can be
 * particularly useful in simulations, where this feature can be used to control
 * playback speed.
 *
 * When an application passes 0 to delta_time, ecs_progress will automatically
 * measure the time passed since the last frame. If an application does not uses
 * time management, it should pass a non-zero value for delta_time (1.0 is
 * recommended). That way, no time will be wasted measuring the time.
 *
 * @time-complexity: O(s * t)
 * @param world The world to progress.
 * @param delta_time The time passed since the last frame.
 */
FLECS_EXPORT
bool ecs_progress(
    EcsWorld *world,
    float delta_time);

/** Merge staged data.
 * This operation merges data from one or more stages (if there are multiple
 * threads) to the world state. By default, this happens every time ecs_progress
 * is called. To change this to manual merging, call ecs_set_automerge.
 *
 * Calling ecs_merge manually is a performance optimization which trades
 * consistency for speed. By default thread-specific staging areas are merged
 * automatically after each time ecs_progress is called. For some applications
 * this may impact performance too much, in which case manual merging may be
 * used.
 *
 * Manual merging requires that the application logic is capable of handling
 * application state that is out of sync for multiple iterations.
 *
 * @param world The world.
 */
FLECS_EXPORT
void ecs_merge(
    EcsWorld *world);

/** Set whether the world should merge data each frame.
 * By default, ecs_progress merges data each frame. With this operation that
 * behavior can be changed to merge manually, using ecs_merge.
 *
 * Merging is an expensive task, and having to merge each time ecs_progress is
 * called can slow down the application. If ecs_progress is invoked at high
 * frequencies, it may be sufficient to merge at a reduced rate.
 *
 * As a result of delayed merging, any operation that requires adding or
 * removing components from an entity will not be visible to all threads until
 * the merge occurs.
 *
 * @param world The world.
 * @param auto_merge: When true, ecs_progress performs merging.
 */
FLECS_EXPORT
void ecs_set_automerge(
    EcsWorld *world,
    bool auto_merge);

/** Set number of worker threads.
 * This operation sets the number of worker threads to which to distribute the
 * processing load. If this function is called multiple times, the total number
 * of threads running will reflect the number specified in the last call.
 *
 * This function should not be called while processing an iteration, but should
 * only be called before or after calling ecs_progress.
 *
 * The initial value is zero, which means that ecs_progress will only use the
 * mainthread.
 *
 * @time-complexity: O(n)
 * @param world The world.
 * @param threads: The number of threads.
 * @returns EcsOk if successful, or EcsError if failed.
 */
FLECS_EXPORT
EcsResult ecs_set_threads(
    EcsWorld *world,
    uint32_t threads);

/** Set target frames per second (FPS) for application.
 * Setting the target FPS ensures that ecs_progress is not invoked faster than
 * the specified FPS. When enabled, ecs_progress tracks the time passed since
 * the last invocation, and sleeps the remaining time of the frame (if any).
 *
 * This feature ensures systems are ran at a consistent interval, as well as
 * conserving CPU time by not running systems more often than required.
 *
 * This feature depends upon frame profiling. When this operation is called,
 * frame profiling is automatically enabled. Frame profiling can be manually
 * turned on/off with ecs_measure_frame_time. It is not possible to turn off
 * frame profiling if a target FPS is set.
 *
 * Note that ecs_progress only sleeps if there is time left in the frame. Both
 * time spent in flecs as time spent outside of flecs are taken into
 * account.
 *
 * Setting a target FPS can be more efficient than letting the application do it
 * manually, as the feature can reuse clock measurements that are taken for
 * frame profiling as well as automatically measuring delta_time.
 */
FLECS_EXPORT
void ecs_set_target_fps(
    EcsWorld *world,
    float fps);

/** Get last used delta time from world */
FLECS_EXPORT
float ecs_get_delta_time(
    EcsWorld *world);

/** Set a world context.
 * This operation allows an application to register custom data with a world
 * that can be accessed anywhere where the application has the world object.
 *
 * A typical usecase is to register a struct with handles to the application
 * entities, components and systems.
 *
 * @time-complexity: O(1)
 * @param world The world.
 * @param ctx A pointer to a user defined structure.
 */
FLECS_EXPORT
void ecs_set_context(
    EcsWorld *world,
    void *ctx);

/** Get the world context.
 * This operation retrieves a previously set world context.
 *
 * @time-complexity: O(1)
 * @param world The world.
 * @returns The context set with ecs_set_context. If no context was set, the
 *          function returns NULL.
 */
FLECS_EXPORT
void* ecs_get_context(
    EcsWorld *world);

/** Dimension the world for a specified number of entities.
 * This operation will preallocate memory in the world for the specified number
 * of entities. Specifying a number lower than the current number of entities in
 * the world will have no effect.
 *
 * When using this operation, note that flecs uses entities for storing
 * systems, components and builtin components. For an exact calculation of
 * entities, do user_entity_count + component_count + system_count + 3. The 3
 * stands for the number of builtin components.
 *
 * Note that this operation does not allocate memory in tables. To preallocate
 * memory in a table, use ecs_dim_type. Correctly using these functions
 * prevents flecs from doing dynamic memory allocations in the main loop.
 *
 * @time-complexity: O(1)
 * @param world The world.
 * @param entity_count The number of entities to preallocate.
 */
FLECS_EXPORT
void ecs_dim(
    EcsWorld *world,
    uint32_t entity_count);

/** Dimension a type for a specified number of entities.
 * This operation will preallocate memory for a type (table) for the
 * specified number of entites. Specifying a number lower than the current
 * number of entities in the table will have no effect.
 *
 * If no table exists yet for this type (when no entities have been committed
 * for the type) it will be created, even if the entity_count is zero. This
 * operation can thus also be used to just preallocate empty tables.
 *
 * If the specified type is unknown, the behavior of this function is
 * unspecified. To ensure that the type exists, use ecs_type_get or
 * ECS_TYPE.
 *
 * @time-complexity: O(1)
 * @param world The world.
 * @param type Handle to the type, as obtained by ecs_type_get.
 * @param entity_count The number of entities to preallocate.
 */
FLECS_EXPORT
void _ecs_dim_type(
    EcsWorld *world,
    EcsType type,
    uint32_t entity_count);

/* Macro to ensure you don't accidentally pass a non-type into the function */
#define ecs_dim_type(world, type, entity_count)\
    _ecs_dim_type(world, T##type, entity_count)

/* -- Entity API -- */

/** Create a new entity.
 * Entities are light-weight objects that represent "things" in the application.
 * Entities themselves do not have any state or logic, but instead are composed
 * out of a set of zero or more components.
 *
 * The memory occupied by an entity is the combined size of its components plus
 * approximately 40 bytes. Component lists are shared between entities,
 * thus adding a component to one entity does not necessarily increase
 * footprint. Each active combination of components is stored exactly once.
 *
 * Component data is stored in tables, with one table for each combination of
 * components. An entity is stored in the table that matches its component list.
 * When components are added or removed from an entity, the entity is moved to
 * another table.
 *
 * Entities are accessed through handles instead of direct pointers. Certain
 * operations may move an entity in memory. Handles provide a safe mechanism for
 * addressing entities. The average lookup complexity for a handle is O(1).
 *
 * @time-complexity: O(1)
 * @param world The world to which to add the entity.
 * @param type Zero if no type, or handle to a component, type or prefab.
 * @returns A handle to the new entity.
 */
FLECS_EXPORT
EcsEntity _ecs_new(
    EcsWorld *world,
    EcsType type);

/* Macro to ensure you don't accidentally pass a non-type into the function */
#define ecs_new(world, type)\
    _ecs_new(world, T##type)

/** Create a new child entity.
 * Child entities are equivalent to normal entities, but can additionally be 
 * created with a container entity. Container entities allow for the creation of
 * entity hierarchies.
 * 
 * This function is equivalent to calling ecs_new with a type that combines both
 * the type specified in this function and the type id for the container.
 * 
 * If the provided parent entity does not have the 'EcsContainer' component, it
 * will be added automatically.
 */
FLECS_EXPORT
EcsEntity _ecs_new_child(
    EcsWorld *world,
    EcsEntity parent,
    const char *name,
    EcsType type);

/* Macro to ensure you don't accidentally pass a non-type into the function */
#define ecs_new_child(world, parent, name, type)\
    _ecs_new_child(world, parent, name, T##type)

/** Convenience function to create an entity with id and component expression */
FLECS_EXPORT
EcsEntity ecs_new_entity(
    EcsWorld *world,
    const char *id,
    const char *components);

/** Create a new set of entities.
 * This operation creates the number of specified entities with one API call
 * which is a more efficient alternative to calling ecs_new in a loop.
 *
 * @param world The world.
 * @param type Zero if no type, or handle to a component, type or prefab.
 * @param count The number of entities to create.
 * @param handles_out An array which contains the handles of the new entities.
 * @returns The handle to the first created entity.
 */
FLECS_EXPORT
EcsEntity _ecs_new_w_count(
    EcsWorld *world,
    EcsType type,
    uint32_t count,
    EcsEntity *handles_out);

/* Macro to ensure you don't accidentally pass a non-type into the function */
#define ecs_new_w_count(world, type, count, handles_out)\
    _ecs_new_w_count(world, T##type, count, handles_out)

/** Create new entity with same components as specified entity.
 * This operation creates a new entity which has the same components as the
 * specified entity. This includes prefabs and entity-components (entities to
 * which the EcsComponent component has been added manually).
 *
 * The application can optionally copy the values of the specified entity by
 * passing true to copy_value. In that case, the resulting entity will have the
 * same value as source specified entity.
 *
 * @param world The world.
 * @param entity The source entity.
 * @param copy_value Whether to copy the entity value.
 * @returns The handle to the new entity.
 */
FLECS_EXPORT
EcsEntity ecs_clone(
    EcsWorld *world,
    EcsEntity entity,
    bool copy_value);

/** Delete an existing entity.
 * Deleting an entity in most cases causes the data of another entity to be
 * copied. This happens to prevent memory fragmentation. It means that for
 * entities with lots of components (or few large ones) deleting can be an
 * expensive operation.
 *
 * After this operation the handle will be invalidated and should no longer be
 * used. Handles are not recycled, which implies a finite number of new / delete
 * operations. In the current implementation that number is 2^64 - 1, which
 * should keep code running until the sun runs out of fuel. Possibly longer.
 *
 * The only post condition for this function is that no entity with the
 * specified handle will exist after the operation. If a handle is provided to
 * the function that does not resolve to an entity, this function is a no-op.
 *
 * @time-complexity: O(r)
 * @param world The world.
 * @param entity A handle to the entity to delete.
 */
FLECS_EXPORT
void ecs_delete(
    EcsWorld *world,
    EcsEntity entity);

/** Add a type to an entity */
FLECS_EXPORT
EcsResult _ecs_add(
    EcsWorld *world,
    EcsEntity entity,
    EcsType component);

/* Macro to ensure you don't accidentally pass a non-type into the function */
#define ecs_add(world, entity, type)\
    _ecs_add(world, entity, T##type)

/** Remove a type from an entity */
FLECS_EXPORT
EcsResult _ecs_remove(
    EcsWorld *world,
    EcsEntity entity,
    EcsType type);

/* Macro to ensure you don't accidentally pass a non-type into the function */
#define ecs_remove(world, entity, type)\
    _ecs_remove(world, entity, T##type)

/** Adopt a child entity by a parent */
FLECS_EXPORT
EcsResult ecs_adopt(
    EcsWorld *world,
    EcsEntity parent,
    EcsEntity child);

/** Orphan a child by a parent */
FLECS_EXPORT
EcsResult ecs_orphan(
    EcsWorld *world,
    EcsEntity parent,
    EcsEntity child);

/** Get pointer to component data.
 * This operation obtains a pointer to the component data of an entity. If the
 * component was not added for the specified entity, the operation will return
 * NULL.
 *
 * Note that the returned pointer has temporary validity. Operations such as
 * delete and commit may invalidate the pointer as data is potentially moved
 * to different locations. After one of these operations is invoked, the pointer
 * will have to be re-obtained.
 *
 * This function is wrapped by the ecs_get convenience macro, which can be
 * used like this:
 *
 * Foo value = ecs_get(world, e, Foo);
 *
 * @time-complexity: O(c)
 * @param world The world.
 * @param entity Handle to the entity from which to obtain the component data.
 * @param component The component to retrieve the data for.
 * @returns A pointer to the data, or NULL of the component was not found.
 */
FLECS_EXPORT
void* _ecs_get_ptr(
    EcsWorld *world,
    EcsEntity entity,
    EcsType type);

/* Macro to ensure you don't accidentally pass a non-type into the function */
#define ecs_get_ptr(world, entity, type)\
    _ecs_get_ptr(world, entity, T##type)

/* Convenienve macro for returning a value instead of a pointer */
#define ecs_get(world, entity, type)\
  (*(type*)_ecs_get_ptr(world, entity, T##type))

#define ecs_get_singleton(world, type)\
    (*(type*)_ecs_get_ptr(world, 0, T##type))

#define ecs_get_singleton_ptr(world, type)\
    _ecs_get_ptr(world, 0, T##type)

/* Set value of component.
 * This function sets the value of a component on the specified entity. If the
 * component does not yet exist, it will be added to the entity.
 *
 * This function can be used like this:
 * Foo value = {.x = 10, .y = 20};
 * ecs_set_ptr(world, e, tFoo, &value);
 *
 * This function is wrapped by the ecs_set convenience macro, which can be used
 * like this:
 *
 * ecs_set(world, e, Foo, {.x = 10, .y = 20});
 *
 * @param world The world.
 * @param entity The entity on which to set the component.
 * @param component The component to set.
 */
FLECS_EXPORT
EcsEntity _ecs_set_ptr(
    EcsWorld *world,
    EcsEntity entity,
    EcsType type,
    size_t size,
    void *ptr);

FLECS_EXPORT
EcsEntity _ecs_set_singleton_ptr(
    EcsWorld *world,
    EcsType type,
    size_t size,
    void *ptr);

#define ecs_set_ptr(world, entity, type, ptr)\
    _ecs_set_ptr(world, entity, T##type, sizeof(type), ptr)

#define ecs_set(world, entity, type, ...)\
    _ecs_set_ptr(world, entity, T##type, sizeof(type), &(type)__VA_ARGS__)

#define ecs_set_singleton(world, type, ...)\
    _ecs_set_singleton_ptr(world, T##type, sizeof(type), &(type)__VA_ARGS__)

#define ecs_set_singleton_ptr(world, type, ptr)\
    _ecs_set_singleton_ptr(world, T##type, sizeof(type), ptr)

/** Check if entity has the specified type.
 * This operation checks if the entity has the components associated with the
 * specified type. It accepts component handles, families and prefabs.
 *
 * For example, if an entity has component 'Foo' and a type has 'Foo, Bar'
 * invoking this function with the entity and type as type will return false
 * because the entity does not have 'Bar'. Invoking the entity with the 'Bar'
 * component, or a type that contains only 'Bar' will return true.
 *
 * @time-complexity: O(c)
 * @param world The world.
 * @param entity Handle to a entity.
 * @param type Handle to a component, type or prefab.
 * @returns true if entity has type, otherwise false.
 */
FLECS_EXPORT
bool _ecs_has(
    EcsWorld *world,
    EcsEntity entity,
    EcsType type);

/* Macro to ensure you don't accidentally pass a non-type into the function */
#define ecs_has(world, entity, type)\
    _ecs_has(world, entity, T##type)

/** Check if entity has any of the components in the specified type.
 * This operation checks if the entity has any of the components associated with
 * the specified type. It accepts component handles, families and prefabs.
 *
 * For example, if an entity has component 'Foo' and a type has 'Foo, Bar'
 * invoking this function with the entity and type as type will return true
 * because the entity has one of the components.
 *
 * @time-complexity: O(c)
 * @param world The world.
 * @param entity Handle to a entity.
 * @param type Handle to a component, type or prefab.
 * @returns true if entity has one of the components, otherwise false.
 */
FLECS_EXPORT
bool _ecs_has_any(
    EcsWorld *world,
    EcsEntity entity,
    EcsType type);

#define ecs_has_any(world, entity, type)\
    _ecs_has_any(world, entity, T##type)

/** Check if parent entity contains child entity */
FLECS_EXPORT
bool ecs_contains(
    EcsWorld *world,
    EcsEntity parent,
    EcsEntity child);


/** Return if the entity is valid.
 * This returns whether the provided entity handle is valid. An entity that has
 * never been returned by ecs_new (or variants) or that has been deleted with
 * ecs_delete is not valid.
 *
 * @param world The world.
 * @param entity The entity handle.
 * @returns true if valid, false if not valid.
 */
FLECS_EXPORT
bool ecs_empty(
    EcsWorld *world,
    EcsEntity entity);

/** Get type of entity */
FLECS_EXPORT
EcsType ecs_typeid(
    EcsWorld *world,
    EcsEntity entity);

/** Get component from entity */
FLECS_EXPORT
EcsEntity ecs_get_component(
    EcsWorld *world,
    EcsEntity entity,
    uint32_t index);

/* -- Id API -- */

/** Return the entity id.
 * This returns the string identifier of an entity, if the entity has the EcsId
 * component. By default, all component, type, system and prefab entities add
 * the EcsId component if they have been created with the ecs_new_* functions.
 *
 * If the entity does not contain the EcsId component, this function will return
 * NULL.
 *
 * @param world The world.
 * @param entity The entity for which to resolve the id.
 * @returns The id of the entity.
 */
FLECS_EXPORT
const char* ecs_id(
    EcsWorld *world,
    EcsEntity entity);

/** Lookup an entity by id.
 * This operation is a convenient way to lookup entities by string identifier
 * that have the EcsId component. It is recommended to cache the result of this
 * function, as the function must iterates over all entities and all components
 * in an entity.
 *
 * @time-complexity: O(t * c)
 * @param world The world.
 * @param id The id to lookup.
 * @returns The entity handle if found, or ECS_HANDLE_NIL if not found.
 */
FLECS_EXPORT
EcsEntity ecs_lookup(
    EcsWorld *world,
    const char *id);


/* -- Component API -- */

/** Create a new component.
 * This operation creates a new component with a specified id and size. After
 * this operation is called, the component can be added to entities by using
 * the returned handle with ecs_add.
 *
 * Components represent the data of entities. An entity can be composed out of
 * zero or more components. Internally compoments are stored in tables that
 * are created for active combinations of components in a world.
 *
 * This operation accepts a size, which is the size of the type that contains
 * the component data. Any native type can be used, and the size can be
 * obtained with the built-in sizeof function. For convenience, an application
 * may use the ECS_COMPONENT macro instead of calling this function directly.
 *
 * Components are stored internally as entities. This operation is equivalent
 * to creating an entity with the EcsComponent and EcsId components. The
 * returned handle can be used in any function that accepts an entity handle.
 *
 * @time-complexity: O(2 * r + c)
 * @param world The world.
 * @param id A unique component identifier.
 * @param size The size of the component type (as obtained by sizeof).
 * @returns A handle to the new component, or ECS_HANDLE_NIL if failed.
 */
FLECS_EXPORT
EcsEntity ecs_new_component(
    EcsWorld *world,
    const char *id,
    size_t size);


/* -- Type API -- */

/** Get handle to type.
 * This operation obtains a handle to a type that can be used with
 * ecs_new. Predefining types has performance benefits over using
 * ecs_add/ecs_remove multiple times, as it provides constant
 * creation time regardless of the number of components. This function will
 * internally create a table for the type.
 *
 * If a type had been created for this set of components before with the same
 * identifier, the existing type is returned. If the type had been created
 * with a different identifier, this function will fail.
 *
 * The ECS_TYPE macro wraps around this function.
 *
 * @time-complexity: O(c)
 * @param world The world.
 * @param components A comma-separated string with the component identifiers.
 * @returns Handle to the type, zero if failed.
 */
FLECS_EXPORT
EcsType ecs_new_type(
    EcsWorld *world,
    const char *id,
    const char *components);

/** Create a new prefab entity.
 * Prefab entities allow entities to share a set of components. Components of
 * the prefab will appear on the specified entity when using any of the API
 * functions and ECS systems.
 *
 * A prefab is a regular entity, with the only difference that it has the
 * EcsPrefab component.
 *
 * The ECS_PREFAB macro wraps around this function.
 *
 * Changing the value of one of the components on the prefab will change the
 * value for all entities that added the prefab, as components are stored only
 * once in memory. This makes prefabs also a memory-saving mechanism; there can
 * be many entities that reuse component records from the prefab.
 *
 * Entities can override components from a prefab by adding the component with
 * ecs_add. When a component is overridden, its value will be copied from the
 * prefab. This technique can be combined with families to automatically
 * initialize entities, like this:
 *
 * ECS_PREFAB(world, MyPrefab, Foo);
 * ECS_TYPE(world, MyType, MyPrefab, Foo);
 * EcsEntity e = ecs_new(world, MyType);
 *
 * In this code, the entity will be created with the prefab and directly
 * override 'Foo', which will copy the value of 'Foo' from the prefab.
 *
 * Prefabs are explicitly stored on the component list of an entity. This means
 * that two entities with the same set of components but a different prefab are
 * stored in different tables.
 *
 * Prefabs can be part of the component list of other prefabs. This allows for
 * creating hierarchies of prefabs, where the leaves are the most specialized.
 *
 * Only one prefab may be added to an entity.
 */
FLECS_EXPORT
EcsEntity ecs_new_prefab(
    EcsWorld *world,
    const char *id,
    const char *sig);


/* -- Type API -- */

/** Get a type from an entity.
 * This function returns a type that can be added/removed to entities. If you
 * create a new component, type or prefab with the ecs_new_* function, you get
 * an EcsEntity handle which provides access to builtin components associated
 * with the component, type or prefab.
 * 
 * To add a component to an entity, you first have to obtain its type. Types
 * uniquely identify sets of one or more components, and can be used with
 * functions like ecs_add and ecs_remove.
 * 
 * You can only obtain types from entities that have EcsComponent, EcsPrefab,
 * EcsTypeComponent or EcsContainer. These components are automatically added
 * by the ecs_new_* functions, but can also be added manually.
 * 
 * The ECS_COMPONENT, ECS_TAG, ECS_TYPE or ECS_PREFAB macro's will auto-
 * declare a variable containing the type called tFoo (where 'Foo' is the id
 * provided to the macro).
 */
FLECS_EXPORT
EcsType ecs_type_from_entity(
    EcsWorld *world,
    EcsEntity entity);


/** Get an entity from a type.
 * This function is the reverse of ecs_type_from_entity. It only works for types
 * that contain exactly one entity. */
FLECS_EXPORT
EcsEntity ecs_entity_from_type(
    EcsWorld *world,
    EcsType entity);


/** Merge two types. */
FLECS_EXPORT
EcsType _ecs_merge_type(
    EcsWorld *world,
    EcsType type,
    EcsType type_add,
    EcsType type_remove);

#define ecs_merge_type(world, type, type_add, type_remove)\
    _ecs_merge_type(world, T##type, T##type_add, T##type_remove)

/* -- System API -- */

/** Create a new system.
 * This operation creates a new system with a specified id, kind and action.
 * After this operation is called, the system will be active. Systems can be
 * created with three different kinds:
 *
 * - EcsOnFrame: the system is invoked when ecs_progress is called.
 * - EcsOnAdd: the system is invoked when a component is committed to memory.
 * - EcsOnRemove: the system is invoked when a component is removed from memory.
 * - EcsManual: the system is only invoked on demand (ecs_run)
 *
 * The signature of the system is a string formatted as a comma separated list
 * of component identifiers. For example, a system that wants to receive the
 * Location and Speed components, should provide "Location, Speed" as its
 * signature.
 *
 * The action is a function that is invoked for every entity that has the
 * components the system is interested in. The action has three parameters:
 *
 * - EcsEntity system: Handle to the system (same as returned by this function)
 * - EcsEntity entity: Handle to the current entity
 * - void *data[]: Array of pointers to the component data
 *
 * Systems are stored internally as entities. This operation is equivalent to
 * creating an entity with the EcsSystem and EcsId components. The returned
 * handle can be used in any function that accepts an entity handle.
 *
 * @time-complexity: O(2 * r + c)
 * @param world The world.
 * @param id The identifier of the system.
 * @param kind The kind of system.
 * @param signature The signature that describes the components.
 * @param action The action that is invoked for matching entities.
 * @returns A handle to the system.
 */
FLECS_EXPORT
EcsEntity ecs_new_system(
    EcsWorld *world,
    const char *id,
    EcsSystemKind kind,
    const char *sig,
    EcsSystemAction action);

/** Enable or disable a system.
 * This operation enables or disables a system. A disabled system will not be
 * ran during ecs_progress or when components must be initialized or
 * deinitialized. Systems are enabled by default.
 *
 * This operation expects a valid system handle, or in other words, an entity
 * with the EcsSystem component. If a handle to an entity is provided that does
 * not have this component, the operation will fail.
 *
 * @time-complexity: O(c)
 * @param world The world.
 * @param system The system to enable or disable.
 * @param enabled true to enable the system, false to disable the system.
 * @returns EcsOk if succeeded, EcsError if the operation failed.
 */
FLECS_EXPORT
void ecs_enable(
    EcsWorld *world,
    EcsEntity system,
    bool enabled);

/** Configure how often a system should be invoked.
 * This operation lets an application control how often a system should be
 * invoked. The provided period is the minimum interval between two invocations.
 *
 * Correct operation of this feature relies on an application providing a
 * delta_time value to ecs_progress. Once the delta_time exceeds the period that
 * is specified for a system, ecs_progress will invoke it.
 *
 * This operation is only valid on EcsPeriodic systems. If it is invoked on
 * handles of other systems or entities it will be ignored. An application may
 * only set the period outside ecs_progress.
 *
 * Note that a system will never be invoked more often than ecs_progress is
 * invoked. If the specified period is smaller than the interval at which
 * ecs_progress is invoked, the system will be invoked at every ecs_progress,
 * provided that the delta_time provided to ecs_progress is accurate.
 *
 * @param world The world.
 * @param system The system for which to set the period.
 * @param period The period.
 */
FLECS_EXPORT
void ecs_set_period(
    EcsWorld *world,
    EcsEntity system,
    float period);

/** Returns the enabled status for a system / entity.
 * This operation will return whether a system is enabled or disabled. Currently
 * only systems can be enabled or disabled, but this operation does not fail
 * when a handle to an entity is provided that is not a system. If this
 * operation is called on a non-system entity, the operation will return true.
 *
 * @time-complexity: O(c)
 * @param world The world.
 * @param system The system to check.
 * @returns True if the system is enabled, false if the system is disabled.
 */
FLECS_EXPORT
bool ecs_is_enabled(
    EcsWorld *world,
    EcsEntity system);

/** Run a specific system manually.
 * This operation runs a single system on demand. It is an efficient way to
 * invoke logic on a set of entities, as on demand systems are only matched to
 * tables at creation time or after creation time, when a new table is created.
 *
 * On demand systems are useful to evaluate lists of prematched entities at
 * application defined times. Because none of the matching logic is evaluated
 * before the system is invoked, on demand systems are much more efficient than
 * manually obtaining a list of entities and retrieving their components.
 *
 * An application may however want to apply a filter to an on demand system for
 * fast-changing unpredictable selections of entity subsets. The filter
 * parameter lets applications pass handles to components or component families,
 * and only entities that have said components will be evaluated.
 *
 * Because the filter is evaluated not on a per-entity basis, but on a per table
 * basis, filter evaluation is still very cheap, especially when compared to
 * tables with large numbers of entities.
 *
 * An application may pass custom data to a system through the param parameter.
 * This data can be accessed by the system through the param member in the
 * EcsRows value that is passed to the system callback.
 *
 * Any system may interrupt execution by setting the interrupted_by member in
 * the EcsRows value. This is particularly useful for on demand systems, where
 * the value of interrupted_by is returned by this operation. This, in
 * cominbation with the param argument lets applications use on demand systems
 * to lookup entities: once the entity has been found its handle is passed to
 * interrupted_by, which is then subsequently returned.
 *
 * @time-complexity: O(t)
 * @param world The world.
 * @param system The system to run.
 * @param delta_time: The time passed since the last system invocation.
 * @param filter A component or type to filter matched entities.
 * @param param A user-defined parameter to pass to the system.
 * @returns handle to last evaluated entity if system was interrupted.
 */
FLECS_EXPORT
EcsEntity ecs_run(
    EcsWorld *world,
    EcsEntity system,
    float delta_time,
    void *param);

/** Run system with offset/limit and type filter */
FLECS_EXPORT
EcsEntity _ecs_run_w_filter(
    EcsWorld *world,
    EcsEntity system,
    float delta_time,
    uint32_t offset,
    uint32_t limit,
    EcsType filter,
    void *param);

#define ecs_run_w_filter(world, system, delta_time, offset, limit, type, param)\
    _ecs_run_w_filter(world, system, delta_time, offset, limit, T##type, param)

/* Obtain a column from inside a system */
FLECS_EXPORT
void* _ecs_column(
    EcsRows *rows,
    uint32_t index,
    bool test);

#define ecs_column(rows, type, index)\
    ((type*)_ecs_column(rows, index, false))

#define ecs_column_test(rows, type, index)\
    ((type*)_ecs_column(rows, index, true))

/* Obtain a reference to a shared component */
FLECS_EXPORT
void* _ecs_shared(
    EcsRows *rows,
    uint32_t index,
    bool test);

#define ecs_shared(rows, type, index)\
    ((type*)_ecs_shared(rows, index, false))

#define ecs_shared_test(rows, type, index)\
    ((type*)_ecs_shared(rows, index, true))

/** Obtain the source of a column from inside a system.
 * This operation lets you obtain the entity from which the column data was
 * resolved. In most cases a component will come from the entities being
 * iterated over, but when using prefabs or containers, the component can be
 * shared between entities. For shared components, this function will return the
 * original entity on which the component is stored.
 * 
 * If a column is specified for which the component is stored on the entities
 * being iterated over, the operation will return 0, as the entity id in that
 * case depends on the row, not on the column. To obtain the entity ids for a
 * row, a system should access the entity column (column zero) like this:
 * 
 * EcsEntity *entities = ecs_column(rows, EcsEntity, 0);
 * 
 * @param rows Pointer to the rows object passed into the system callback.
 * @param index An index identifying the column for which to obtain the component.
 * @return The source entity for the column. 
 */
FLECS_EXPORT
EcsEntity ecs_column_source(
    EcsRows *rows,
    uint32_t index);

/** Obtain the component for a column inside a system.
 * This operation obtains the component handle for a column in the system. This
 * function wraps around the 'components' array in the EcsRows type.
 * 
 * Note that since component identifiers are obtained from the same pool as
 * regular entities, the return type of this function is EcsEntity.
 * 
 * When a system contains an argument that is prefixed with 'ID', the resolved
 * entity will be accessible through this function as well.
 * 
 * Column indices for system arguments start from 1, where 0 is reserved for a
 * column that contains entity identifiers. Passing 0 to this function for the
 * column index will return 0.
 * 
 * @param rows Pointer to the rows object passed into the system callback.
 * @param index An index identifying the column for which to obtain the component.
 * @return The component for the specified column, or 0 if failed.
 */
FLECS_EXPORT
EcsEntity ecs_column_component(
    EcsRows *rows,
    uint32_t index);

/** Obtain the type of a column from inside a system. 
 * This operation is equivalent to ecs_column_component, except that it returns
 * a type, instead of an entity handle. Invoking this function is the same as
 * doing:
 * 
 * ecs_type_from_entity( ecs_column_component(rows, index));
 * 
 * To use the result of this operation with functions like ecs_new, ecs_add and 
 * ecs_set, make sure to name the variable in which you store the result of this
 * function T<typename>. For example, for a type called Position, you should do:
 * 
 * EcsType TPosition = ecs_column_type(rows, 1);
 * 
 * This ensures that you can use functions like ecs_set like this:
 * 
 * ecs_set(world, e, Position, {10, 20});
 * 
 * @param rows Pointer to the rows object passed into the system callback.
 * @param index An index identifying the column for which to obtain the component.
 * @return The type for the specified column, or 0 if failed.
 */ 
FLECS_EXPORT
EcsType ecs_column_type(
    EcsRows *rows,
    uint32_t index);

/* -- Error handling & error codes -- */

/** Throw an error */
FLECS_EXPORT
void ecs_throw(
    uint32_t error_code,
    const char *param);

/** Raise last error to terminal */
FLECS_EXPORT
uint32_t ecs_raise(void);

/** Catch last error */
FLECS_EXPORT
uint32_t ecs_catch(void);

/** Get description for error code */
FLECS_EXPORT
const char* ecs_strerror(
    uint32_t error_code);

/** Abort */
FLECS_EXPORT
void _ecs_abort(
    uint32_t error_code,
    const char *param,
    const char *file,
    uint32_t line);

/** Assert */
FLECS_EXPORT
void _ecs_assert(
    bool condition,
    uint32_t error_code,
    const char *param,
    const char *condition_str,
    const char *file,
    uint32_t line);

#define ecs_abort(error_code, param) _ecs_abort(error_code, param, __FILE__, __LINE__)
#define ecs_assert(condition, error_code, param) _ecs_assert(condition, error_code, param, #condition, __FILE__, __LINE__)

#define ECS_INVALID_HANDLE (1)
#define ECS_INVALID_PARAMETERS (2)
#define ECS_INVALID_COMPONENT_ID (3)
#define ECS_INVALID_COMPONENT_EXPRESSION (4)
#define ECS_UNKNOWN_COMPONENT_ID (5)
#define ECS_UNKNOWN_TYPE_ID (6)
#define ECS_TYPE_NOT_AN_ENTITY (7)
#define ECS_MISSING_SYSTEM_CONTEXT (8)
#define ECS_NOT_A_COMPONENT (9)
#define ecs_type_IN_USE (10)
#define ECS_INTERNAL_ERROR (11)
#define ECS_MORE_THAN_ONE_PREFAB (12)
#define ECS_ENTITY_ALREADY_DEFINED (13)
#define ECS_INVALID_COMPONENT_SIZE (14)
#define ECS_OUT_OF_MEMORY (15)
#define ECS_MODULE_UNDEFINED (16)
#define ECS_COLUMN_INDEX_OUT_OF_RANGE (17)
#define ECS_COLUMN_IS_NOT_SHARED (18)
#define ECS_COLUMN_IS_SHARED (19)
#define ECS_INVALID_WHILE_MERGING (20)

/* -- Convenience macro's -- */

/** Wrapper around ecs_new_entity. */ 
#define ECS_ENTITY(world, id, ...)\
    EcsEntity id = ecs_new_entity(world, #id, #__VA_ARGS__);\
    (void)id;\
    assert (id != 0)

/** Wrapper around ecs_new_component.
 * This macro provides a convenient way to register components with a world. It
 * can be used like this:
 *
 * ECS_COMPONENT(world, Location);
 *
 * In this example, "Location" must be a valid C type name. After the macro,
 * the application will have access to a Location_h variable which holds the
 * handle to the new component. */
#define ECS_COMPONENT(world, id) \
    EcsEntity E##id = ecs_new_component(world, #id, sizeof(id));\
    assert (E##id != 0);\
    EcsType T##id = ecs_type_from_entity(world, E##id);\
    (void)E##id;\
    (void)T##id;\
    assert (T##id != 0)

/** Same as component, but no size */
#define ECS_TAG(world, id) \
    EcsEntity E##id = ecs_new_component(world, #id, 0);\
    assert (E##id != 0);\
    EcsType T##id = ecs_type_from_entity(world, E##id);\
    (void)E##id;\
    (void)T##id;\
    assert (T##id != 0)

/** Wrapper around ecs_new_type.
 * This macro provides a convenient way to register a type with the world.
 * It can be used like this:
 *
 * ECS_TYPE(world, MyType, ComponentA, ComponentB);
 * EcsEntity h = ecs_new(world, MyType_h);
 *
 * Creating a type and using it with ecs_new/ecs_add is faster
 * than calling ecs_add multiple types. */
#define ECS_TYPE(world, id, ...) \
    EcsEntity E##id = ecs_new_type(world, #id, #__VA_ARGS__);\
    assert (E##id != 0);\
    EcsType T##id = ecs_type_from_entity(world, E##id);\
    (void)E##id;\
    (void)T##id;\
    assert (T##id != 0)

/** Wrapper around ecs_new_prefab.
 * This macro provides a convenient way to register a prefab with the world. It
 * can be used like this:
 *
 * ECS_PREFAB(world, MyPrefab, ComponentA, ComponentB);
 * EcsEntity h = ecs_new(world, MyPrefab_h);
 *
 * For more specifics, see description of ecs_new_prefab. */
#define ECS_PREFAB(world, id, ...) \
    EcsEntity id = ecs_new_prefab(world, #id, #__VA_ARGS__);\
    assert (id != 0);\
    EcsType T##id = ecs_type_from_entity(world, id);\
    (void)id;\
    (void)T##id;\
    assert (T##id != 0)


/** Wrapper around ecs_new_system.
 * This macro provides a convenient way to register systems with a world. It can
 * be used like this:
 *
 * ECS_SYSTEM(world, Move, EcsOnFrame, Location, Speed);
 *
 * In this example, "Move" must be the identifier to a C function that matches
 * the signature of EcsSystemAction. The signature of this component will be
 * "Location, Speed".
 *
 * After the macro, the application will have access to a Move_h variable which
 * holds the handle to the new system. */
#define ECS_SYSTEM(world, id, kind, ...) \
    EcsEntity F##id = ecs_new_system(world, #id, kind, #__VA_ARGS__, id);\
    EcsEntity id = F##id;\
    (void)id;\
    assert (id != 0)

/** Wrapper around ecs_load.
 * This macro provides a convenient way to load a module with the world. It can
 * be used like this:
 *
 * ECS_IMPORT(world, EcsSystemsMovement, 0);
 *
 * ecs_enable(world, EcsSystemsMovement_h.Move); */
#define ECS_IMPORT(world, module, flags) \
    module##Handles M##module;\
    EcsEntity E##module = ecs_import(world, module, #module, flags, &M##module, sizeof(module##Handles));\
    EcsType T##module = ecs_type_from_entity(world, E##module);\
    module##_ImportHandles(M##module);\
    (void)E##module;\
    (void)T##module

#define ECS_IMPORT_COLUMN(rows, module, column) \
    module##Handles *M##module##_ptr = ecs_shared(rows, module##Handles, column);\
    ecs_assert(M##module##_ptr != NULL, ECS_MODULE_UNDEFINED, #module);\
    module##Handles M##module = *M##module##_ptr;\
    module##_ImportHandles(M##module)

/** Utility macro for declaring a component inside a handles type */
#define ECS_DECLARE_COMPONENT(component)\
    EcsEntity E##component;\
    EcsType T##component

/** Utility macro for declaring a system inside a handles type */
#define ECS_DECLARE_SYSTEM(system)\
    EcsEntity system

/** Utility macro for setting a component in a module function */
#define ECS_SET_COMPONENT(handles, component)\
    handles->E##component = E##component;\
    handles->T##component = T##component

/** Utility macro for setting a system in a module function */
#define ECS_SET_SYSTEM(handles, system)\
    handles->system = system

/** Utility macro for declaring handles by modules */
#define ECS_IMPORT_COMPONENT(handles, component)\
    EcsEntity E##component = handles.E##component; (void)E##component;\
    EcsType T##component = handles.T##component; (void)T##component

/** Utility macro for declaring handles by modules */
#define ECS_IMPORT_SYSTEM(handles, system)\
    EcsEntity system = handles.system; (void)system

/** Utility macro's */
#define ECS_OFFSET(o, offset) (void*)(((uintptr_t)(o)) + ((uintptr_t)(offset)))

#ifdef __cplusplus
}
#endif

#endif
